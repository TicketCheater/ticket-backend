# JPA 를 채택한 이유

## JPA?
- JPA(Java Persistence API)는 자바 진영의 ORM(Object Relational Mapping) 기술 표준이다.
- ORM: 객체와 관계형 DB 를 매핑
- 객체와 테이블믈 매핑해서 패러다임의 불일치 문제를 개발자 대신 해결해준다.

## 패러다임의 불일치?
- 객체지향 프로그래밍: 객체 중심의 접근 방식을 채택한다. 상속, 다형성, 캡슐화 등의 개념을 통해 모듈화되고 확장 가능한 코드를 작성할 수 있다.
- 관계형 데이터베이스: 테이블과 관계를 기반으로 데이터를 저장하고 관리한다. 정규화 및 외래 키 제약 조건을 통해 데이터 일관성을 유지한다.
- 둘의 지향점이 다르기 때문에 패러다임의 불일치가 발생한다. 
- 예를 들어 객체는 상속이라는 기능을 가지고 있지만 테이블은 상속 기능이 없다. 물론 DB 모델링에서 다루는 슈퍼타입 서브타입 관계를 사용하면 되지만, 작성해야 할 코드량이 매우 늘어난다.
- 더 자세한 내용은 `자바 ORM 표준 JPA 프로그래밍` 책을 읽어보도록 하자.

## 주요 특징
- 생산성: 개발자가 객체 지향적으로 데이터를 다룰 수 있어 개발 생산성을 향상시킨다.
- 유지보수: 객체 지향적인 코드를 유지보수하는 것은 관계형 데이터베이스 스키마를 직접 다루는 것보다 훨씬 편하다.
- 패러다임의 불일치 해결: 객체 지향 프로그래밍과 관계형 데이터베이스 사이의 패러다임 불일치를 해결한다.
- 성능: JPA 는 캐시를 통해 성능을 최적화할 수 있으며, 지연 로딩과 즉시 로딩 등의 기능을 제공하여 DB 액세스 성능을 최적화할 수 있다.
- 데이터 접근 추상화와 벤더 독립성: JPA 는 데이터베이스와의 상호 작용을 추상화하여 데이터베이스에 대한 종속성을 줄이고 벤더 독립성을 확보한다. 다양한 DB 를 사용하더라도 코드 변경을 최소화하고 재사용성을 높인다.

## SQL 매퍼(MyBatis, Spring JdbcTemplate)와의 차이점
- SQL 매퍼 역시 객체와 SQL 을 매핑해서 반복적인 개발을 줄여준다.
- 다만, 개발자가 직접 SQL 을 직접 작성해야 하므로 SQL 에 의존적인 개발을 피할 수 없다.

## 반드시 JPA 가 최선인가?
- JPA 는 배치 관련 작업을 할 때 SQL 매퍼에 비해 성능이 확실히 떨어진다.
- 해당 프로젝트에서 티켓을 대량 생산할 때, JPA 를 사용하지 않고, JdbcTemplate 을 사용했다.

## JdbcTemplate 사용 시 주의점
- DB_URL 에 ?rewriteBatchedStatements=true 옵션을 달아줘야 제대로 성능을 낼 수 있다. 
- 20만 개의 티켓을 생성했을 때 해당 옵션을 달아주기 전과 후가 16배의 성능 차이를 보였다. (64000ms -> 4000ms)

## JPA 사용 시 주의점
- JpaRepository 에서 제공하는 기본적인 쿼리 메소드들이 있으나 (find, delete, exists, count ...), 쿼리가 복잡해지면 의도한 대로와는 다르게 동작할 수 있다.
- 이번 프로젝트에서 사용하는 findByIdAndDeletedAtIsNull 이라는 메소드를 예시로 들겠다.
- 내가 의도한 쿼리는 `SELECT t FROM table t WHERE t.id = :id AND t.deletedAt IS NULL` 이었다.
- 그러나 실제 실행된 쿼리는 `SELECT t FROM table t where t.id IS NULL AND t.deletedAt IS NULL` 이었다.
- 이런 상황이 발생하면 JPQL (Java Persistence Query Language) 를 이용하여 쿼리를 더 명확하게 표현하여 오류가 발생하지 않게 하자.
